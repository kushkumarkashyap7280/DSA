// ================  internal of HASH TABLE ====================  

// bucket array ?

// A bucket array is a data structure that divides a large array into smaller, more manageable pieces called buckets. Each bucket can hold a subset of the elements from the original array, allowing for more efficient searching, insertion, and deletion operations. Bucket arrays are often used in conjunction with hashing to implement hash tables, where each bucket corresponds to a specific hash value.


// hash function ?

// A hash function is a function that takes an input (or "key") and returns a fixed-size string of bytes. The output is typically a "digest" that is unique to each unique input. Hash functions are commonly used in hash tables to quickly locate a data record given its search key. A good hash function minimizes the chances of collisions (when two keys hash to the same index) and distributes keys uniformly across the hash table.

// compression function ?

// A compression function is a function that takes a large input (or "key") and reduces it to a smaller, fixed-size output. This is often used in conjunction with hash functions to minimize the amount of data that needs to be stored or transmitted. Compression functions aim to preserve the essential information of the original input while eliminating redundancy, making it easier to work with large datasets.


// hash code ?

// A hash code is a numerical value generated by a hash function from an input (or "key"). It serves as a unique identifier for the input data, allowing for efficient data retrieval in hash tables. The hash code is typically used to determine the index (or bucket) where the corresponding value will be stored in the hash table. A good hash code should minimize collisions and evenly distribute keys across the available buckets.


// what is collision ?

// A collision occurs in a hash table when two different keys hash to the same index (or bucket). This can lead to multiple values being stored in the same location, which can complicate data retrieval and increase the time complexity of operations. To handle collisions, various techniques can be employed, such as chaining (where each bucket contains a linked list of all entries that hash to the same index) or open addressing (where a probing sequence is used to find an empty bucket).

// A good hash table implementation should aim to minimize collisions and maintain efficient performance for all operations.

// collision handling

// open hashing 

// Open hashing, also known as separate chaining, is a collision resolution technique in hash tables where each bucket (or index) in the hash table contains a linked list (or another data structure) of all entries that hash to the same index. When a collision occurs, the new entry is simply added to the linked list for that bucket. This approach allows for efficient handling of collisions, as multiple entries can be stored in the same bucket without requiring a probing sequence. However, it may lead to increased memory usage due to the overhead of maintaining linked lists.

// closed addressing

// Closed addressing, also known as open addressing, is a collision resolution technique in hash tables where, upon a collision, the algorithm searches for the next available bucket (or index) using a probing sequence. This means that all elements are stored directly in the hash table array itself, rather than in linked lists or other data structures. Common probing techniques include linear probing, quadratic probing, and double hashing. Closed addressing can lead to better cache performance and reduced memory overhead compared to chaining, but it may also increase the time complexity of insertions and lookups, especially when the load factor is high.

// separate chaining - Open hashing

// In open hashing, each bucket in the hash table contains a linked list (or another data structure) of all entries that hash to the same index. When a collision occurs, the new entry is simply added to the linked list for that bucket. This approach allows for efficient handling of collisions, as multiple entries can be stored in the same bucket without requiring a probing sequence. However, it may lead to increased memory usage due to the overhead of maintaining linked lists.


// steps : how work internally 

/*

suppose , we want to store large string  in key value form right 
then we have hash function that first convert it into simpler data it may be int or something simpler 
then we use compression function to reduce the size of the data
finally we get the hash code which is unique for that particular data
and insert into bucket  which is an array
but here the twist comes  ,
 
collision

so when two different keys hash to the same index, we have a collision. To handle this, we can use techniques like separate chaining or open addressing.

in separate chaining we make each bucket a linked list, so when a collision occurs, we can simply add the new entry to the list for that bucket.

meanwhile in open addressing, we look for the next available bucket in the hash table to store the new entry. This means that all elements are stored directly in the hash table array itself, rather than in linked lists or other data structures.

*/
